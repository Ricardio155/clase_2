# -*- coding: utf-8 -*-
"""clase 2_Diana Carolina Guamani.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18CGLMe4j-a8iceBUeTR5BSn2GfQWS2Yj

# Clase 2
## En la clase 1 discutimos datos, operadores y métodos. Esta semana discutiremos algunas otras habilidades esenciales que le dan el poder de implementar sus ideas con Python:
* ### Declaraciones condicionales que permiten controlar el flujo de su programa
* ### Bucles que permiten reutilizar instrucciones, sin tener que copiarlas

## De ahora en adelante comenzaremos cada lección con un programa de ejemplo. Los programas de ejemplo le mostrarán las nuevas ideas para esa semana.

* ### En los cuadernos estos ejemplos se llamarán programas de ejemplo
* ### En el programa de ejemplo de esta semana aprenderemos: Cómo leer y escribir archivos
  * #### con comandos elementales como open(), close() y write(), mientras lee con un bucle for
  * #### Cómo crear, leer y escribir (en) una base de datos, usamos Sqlite para esta tarea. Sqlite es una biblioteca estándar de Python
  * #### Hay otras formas de almacenar y recuperar datos, y algunas las veremos en lecciones posteriores, pero ya hacen posible escribir programas serios

# Literatura para la semana 2
* ## La biblioteca random [https://docs.python.org/3/library/random.html](https://docs.python.org/3/library/random.html)
* ## Desde [https://docs.python.org/3/tutorial/index.html](https://docs.python.org/3/tutorial/index.html) capítulo 4 hasta 4.5
* ## [https://www.w3schools.com/python/python_while_loops.asp](https://www.w3schools.com/python/python_while_loops.asp)
* ## [https://www.pythonforbeginners.com/cheatsheet/python-file-handling](https://www.pythonforbeginners.com/cheatsheet/python-file-handling)
* ## Sqlite
  * ### [https://docs.python.org/3/library/sqlite3.html](https://docs.python.org/3/library/sqlite3.html), hasta 'Ver también'
  * ### [https://www.w3schools.com/sql/default.asp](https://www.w3schools.com/sql/default.asp), esta página y mire la columna de la izquierda y estudie las siguientes declaraciones Select, Where, Insert into, Update, Delete, Create DB, Create Table, Drop Table

# Temas para la clase 2
* ## Programa de ejemplo: La programación del juego de adivinanzas contiene todos los temas que tratamos esta semana. Dependiendo de lo que funcione mejor para usted, puede estudiar este ejemplo al principio o al final del material de esta semana. Será discutido en un video separado.
* ## Declaraciones condicionales
  * ### If
  * ### else
  * ### elif
* ## Bucles
  * ### For-loops, para iterar sobre una secuencia (por ejemplo, una colección)
  * ### while-loops
* ## Atajos
  * ### Expresiones condicionales, para reemplazar sentencias condicionales
  * ### Comprensiones, para reemplazar for-loops

# Programa de ejemplo: El juego de adivinanzas
## Escribiremos un juego que le pida al usuario que adivine un número conocido por la computadora. El programa le dará retroalimentación al usuario, ya sea que el usuario adivinó demasiado, demasiado o exactamente bien. Cuando el usuario acertó, el programa elogia al usuario y se detiene.
"""

target = 477
lower_bound = 1
upper_bound = 1000
guesses = 0

# LA funcion input nos permite dar un numero al codigo que esta siendo ejecutado
guess = input(f"Adivina un numero entre {lower_bound} y {upper_bound}")
guesses += 1
while guess != target:
    if guess > target:
        upper_bound = min(upper_bound, guess - 1)
        guess = input(f"Muy alto, por favor intenta otra vez, un numero entre {lower_bound} y {upper_bound}")
    else:
        lower_bound = max(lower_bound, guess + 1)
        guess = input(f"Muy bajo, por favor intenta otra vez, un numero entre  {lower_bound} and {upper_bound}")
    guesses += 1
        
print(f"Bien hecho,solo te tomaron {guesses} intentos.")

"""### Algo salió mal, al leer el mensaje de error concluiríamos que el objetivo o el intento es una cadena.
### Así que ponemos un print statement justo antes de comparar, adivinar y apuntar para ver cuál de los dos es una cadena
### Aunque hay algunas formas muy avanzadas de encontrar errores, es bastante común simplemente imprimir valores y tipos
"""

target = 477
lower_bound = 1
upper_bound = 1000
guesses = 0

# The input functions puts the parameter on the screen and reguesses what is entered by the user 
guess = input(f"Guess a number between {lower_bound} and {upper_bound}")
guesses += 1
while guess != target:
    print(guess, type(guess))
    print(target, type(target))
    if guess > target:
        upper_bound = min(upper_bound, guess - 1)
        guess = input(f"You guessed too high, guess a number between {lower_bound} and {upper_bound}")
    else:
        lower_bound = max(lower_bound, guess + 1)
        guess = input(f"You guessed too low, guess a number between {lower_bound} and {upper_bound}")
    guesses += 1
        
print(f"Well done it only took you {guesses} guesses.")

"""### Al parecer el uso de la funcion intut requiere que nuestro objeto sea un entero."""

target = 477
lower_bound = 1
upper_bound = 1000
guesses = 0

# The input functions puts the parameter on the screen and reguesses what is entered by the user 
guess = int(input(f"Guess a number between {lower_bound} and {upper_bound}"))
guesses += 1
while guess != target:
    # We leave the print statements as comments, maybe we need them more often during testing
    # As soon as we are 100% sure about our program we delete these debugging statements
    # print(guess, type(guess))
    # print(target, type(target))

    if guess > target:
        upper_bound = min(upper_bound, guess - 1)
        guess = int(input(f"You guessed too high, guess a number between {lower_bound} and {upper_bound}"))
    else:
        lower_bound= max(lower_bound, guess + 1)
        guess = int(input(f"You guessed too low, guess a number between {lower_bound} and {upper_bound}"))
    guesses += 1
    
print (f"Well done it only took you {guesses} guesses.")

"""### Por supuesto, el juego es un poco aburrido si siempre es el mismo número que tienes que adivinar, entonces, ¿qué tal si usas un número aleatorio?
### El módulo random debe importarse y luego podemos usarlo para generar un número entero aleatorio
"""

import random
# Vemos el seed the random generator.Al usar esto no importa en donde el numero random sera el mismo siempre

random.seed(100)
target = random.randint(1, 1000)
# Vamos a ayudarnos un poco para no tener que intentar mucho timepo
print(target)

guesses = 0
lower_bound = 1
upper_bound = 1000

 
guess = int(input(f"Guess a number between {lower_bound} and {upper_bound}"))
guesses += 1
while guess != target:
    # print(guess, type(guess))
    # print(target, type(target))

    if guess > target:
        upper_bound = min(upper_bound, guess - 1)
        guess = int(input(f"You guessed too high, guess a number between {lower_bound} and {upper_bound}"))
    else:
        lower_bound= max(lower_bound, guess + 1)
        guess = int(input(f"You guessed too low, guess a number between {lower_bound} and {upper_bound}"))
    guesses += 1

print (f"Well done it only took you {guesses} guesses.")

"""###  Sin el random seed"""

import random

# random.seed(100)
target = random.randint(1, 1000)

print(target)

guesses = 0
lower_bound = 1
upper_bound = 1000


guess = int(input(f"Guess a number between {lower_bound} and {upper_bound}"))
guesses += 1
while guess != target:
    # print(guess, type(guess))
    # print(target, type(target))

    if guess > target:
        upper_bound = min(upper_bound, guess - 1)
        guess = int(input(f"You guessed too high, guess a number between {lower_bound} and {upper_bound}"))
    else:
        lower_bound= max(lower_bound, guess + 1)
        guess = int(input(f"You guessed too low, guess a number between {lower_bound} and {upper_bound}"))
    guesses += 1

print (f"Well done it only took you {guesses} guesses.")

"""### Ahora reescribiremos el programa para que un usuario pueda jugar el juego una y otra vez hasta que ingrese -1"""

import random
guess = 2000
while guess != -1:
    target = random.randint(1, 1000)
    print(target)

    guesses = 0
    lower_bound = 1
    upper_bound = 1000

    guess = int(input(f"Guess a number between {lower_bound} and {upper_bound}"))
    guesses += 1
    
    while guess != target and guess != -1:
         if guess > target:
            upper_bound = min(upper_bound, guess - 1)
            guess = int(input(f"You guessed too high, guess a number between {lower_bound} and {upper_bound}"))
        else:
            lower_bound= max(lower_bound, guess + 1)
            guess = int(input(f"You guessed too low, guess a number between {lower_bound} and {upper_bound}"))
        guesses += 1
    if guess == -1:
        break    
    print (f"Well done it only took you {guesses} guesses.")    

print("Game ended")

"""### Última variación, queremos comparar participantes, por lo tanto, sacamos números aleatorios, pero los escribimos en un archivo.
### Estos números se utilizarán para todos los participantes, para que podamos compararlos
"""

import random
random.seed(100)
random_numbers= open('random_numbers.txt','w')
for i in range(5):
    target = random.randint(1,1000)
    random_numbers.write(target)
random_numbers.close()

"""### El metodo write solo puede escribir cadenas(strings)"""

import random
random.seed(100)
random_numbers = open('random_numbers.txt','w')
for i in range(0,5):
    target = str(random.randint(0,1000)) + "\n"
    random_numbers.write(target)

random_numbers = open('random_numbers.txt','r')
rounds = 0
total_guesses = 0
for target in random_numbers:
    target = int(target)
    print(target)

    guesses = 0
    lower_bound = 1
    upper_bound = 1000

    guess = int(input(f"Guess a number between {lower_bound} and {upper_bound}"))
    guesses += 1
    
    while guess != target and guess != -1:
        if guess > target:
            upper_bound = min(upper_bound, guess - 1)
            guess = int(input(f"You guessed too high, guess a number between {lower_bound} and {upper_bound}"))
        else:
            lower_bound= max(lower_bound, guess + 1)
            guess = int(input(f"You guessed too low, guess a number between {lower_bound} and {upper_bound}"))
        guesses += 1
    if guess == -1:
        break
    print (f"Well done it only took you {guesses} {'guesses' if guesses > 1 else 'guess'}.")
    
    total_guesses += guesses
    rounds += 1
print(f"Game ended, you played {rounds} {'rounds' if rounds > 1 else 'round'} and it took you in total {total_guesses} {'guesses' if total_guesses > 1 else 'guess'}")
# result = 'rounds' if rounds > 1 else 'round' is a shortcut for
# if rounds > 1:
#     result = 'rounds'
# else:
#     result = 'round'
      
random_numbers.close()

"""### Podemos usar sqlite database"""

import random
random.seed(100)

# Here we use a so-called list comprehension, this is a short cut for a for loop in the cell below I will show you
# what the for loop would look like that is replaced by the list comprehension
random_numbers = [(str(index + 1), str(random.randint(0,1000))) for index in range(5)]
print(random_numbers)
# This is a short-cut for
# random_numbers=[]
# for index in range(5):
#     random_numbers.append((str(index + 1), str(random.randint(0,1000))))
# print(random_numbers)

# To use a sqlite3 database you need to import the sqlite3 package
import sqlite3

# You have to make a connection to the database
connection = sqlite3.connect('random numbers.db')

# You have to create a cursor object, while with text files you only needed to muse an open function, here you need two functions
# the connect function and the cursor function
cursor = connection.cursor()

# Delete table, I always do this. First I delete the table if it exists and only then I create a table. Creating a table
# that already exists always gives errors. In this way avoid that
cursor.execute('DROP TABLE IF EXISTS numbers')

# Create table, you always have to create tables. While we just could store data in the txt file, you cannot do that 
# with a database. The data has to be stored in tables inside the database
cursor.execute('CREATE TABLE numbers (index_number text, number text)')

# fill table with values, the executemany function executes the same statement for all the tuples in the random_numbers list. 
# The elements inside the tuple replace the question marks
cursor.executemany('INSERT INTO numbers VALUES (?, ?)', random_numbers)
# This is a short-cut for
# for random_number in random_numbers:
#     cursor.execute(f'INSERT INTO numbers VALUES ({random_number[0]}, {random_number[1]})')

# Save (commit) the changes
connection.commit()
# Just be sure any changes have been committed or they will be lost.

# We can also close the connection if we are done with it.
connection.close()

import sqlite3
# Make connection
#connection = sqlite3.connect(":memory:")
connection = sqlite3.connect('random numbers.db')
# create cursor
cursor = connection.cursor()
# read table
cursor.execute("SELECT * FROM numbers")
# Put result in table
rows = cursor.fetchall()
print (rows)
random_numbers = [int(row[1]) for row in rows]
print (random_numbers)

# We can also close the connection if we are done with it.
# Just be sure any changes have been committed or they will be lost.
connection.close()

rounds = 0
total_guesses = 0
for target in random_numbers:
    target = int(target)
    print(target)

    guesses = 0
    lower_bound = 1
    upper_bound = 1000

    guess = int(input(f"Guess a number between {lower_bound} and {upper_bound}"))
    guesses += 1
    
    while guess != target and guess != -1:
        if guess > target:
            upper_bound = min(upper_bound, guess - 1)
            guess = int(input(f"You guessed too high, guess a number between {lower_bound} and {upper_bound}"))
        else:
            lower_bound= max(lower_bound, guess + 1)
            guess = int(input(f"You guessed too low, guess a number between {lower_bound} and {upper_bound}"))
        guesses += 1
    if guess == -1:
        break
    print (f"Well done it only took you {guesses} {'guesses' if guesses > 1 else 'guess'}.")
    
    total_guesses += guesses
    rounds += 1
print(f"Game ended, you played {rounds} rounds and it took you in total {total_guesses} guesses")

"""### Usar una base de datos para almacenar 5 enteros es una exageración, pero si tiene más datos y los datos están relacionados, las bases de datos son una excelente manera. Por ejemplo, un banco podría tener una tabla de clientes y una tabla con cuentas, y como hay una relación entre clientes y cuentas, usar una base de datos es una buena idea.

# ¿Qué son los condicionales y qué son los bucles?
* ## Los condicionales, dirige el orden de ejecución de los codigos en tu programa. Básicamente, hace que la ejecución de un bloque de código sea condicional, y usted le dice a Python a través de su programa bajo qué condiciones debe ejecutar ese bloque de código.
* ## Bucles, repite un bloque de código (un conjunto de instrucciones) una y otra vez hasta que se cumpla una determinada condición, y le dices a Python a través de tu programa cuál es esta condición
* ## For-loop, la condición es implícita, básicamente le dices al programa que repita un bloque de código siempre que una secuencia produzca (genere) elementos, y le dices al programa qué secuencia usar
 
* ## while-loop, repite un bloque de código siempre que se cumpla una determinada condición, y le dices a Python a través de tu programa cuál es esta condición

# Conditionales

## If clause

### Sintaxis
```python
if <condicion>:
    <statement-1>  # En los bloques de código de Python, las declaraciones if tienen que indentados(sangria)
    <statement-2>  # Las declaraciones que se ejecutarán secuencialmente deben indentarse exactamente de la misma manera
    ...            # Aunque a Python no le importa, es una buena práctica indentar siempre en múltiplos de 4 espacios
                   # El uso de tab no es normalmente utilizado , es considerado como un mal uso pero funciona de todas formas
                   # En resumen, siempre vaya a la siguiente línea y tome 4 espacios después de dos puntos en una declaración
```
### Sintaxis Alternativo
```python
if <condicion>: <statement-1>; <statement-2>; ... 
```
"""

integer_1 = 2
if integer_1 > 1:
    print("integer_1 is greater than 1")

integer_1 = 2
if integer_1 > 1:print("integer_1 is greater than 1")

"""### Else condicional

#### Sintaxis
```python
if <condicion>:
    <statement-1>
    <statement-2>
    ...
else:     #Solo se ejecuta este codigo si es que lo de arriba es falso
    <statement-3>
    <statement-4>
    ...
    
(Lazy evaluation significa que Python solo ejecuta declaraciones cuando es necesario. Por lo tanto, puede encontrar un error en una parte de un programa después de años, ya que esa parte del programa nunca se ejecutó antes y, por lo tanto, nunca se encontró el error)
    
```
####  Sintaxis Alternativo
```python
if <condition>: <statement-1>; <statement-2>; ... 
else: <statement-1>; <statement-2>; ... 
```
"""

integer_1 = 2
if integer_1 > 1:
    print("integer_1 is greater than 1")
else:
    print("integer_1 is not greater than 1")

integer_1 = 0
if integer_1 > 1:
    print("integer_1 is greater than 1")
else:
    print("integer_1 is not greater than 1")

"""### Elif condicional

#### Sintaxis
```python
if <condicion-1>:
    <statement-1>
    <statement-2>
    ...
elif <condition-2>:  # Solo se llega a un elif si todas las demas condiciones han sido falsas
    <statement-3>
    <statement-4>
    ...
elif <condition-3>:
    <statement-5>
    <statement-6>
    ...
...
else:                # SOlo se llega a la clasuala else si es que todas las condiciones son falsas
    <statement-7>    
    <statement-8>
    ...
```

#### Ejemplos
"""

age = 59
if age == 60:
    print("Edad es 60")
elif age == 61:
    print ("Edad es 61")
else:
    print ("La edad no es 60 ni 61")

integer_1 = 0
if integer_1 == 0:
    print("integer_1 es igual a 0")
elif integer_1 > 1:
    print("integer_1 es mayor que 1")
else:
    print("integer_1 no es mayor que 1")

"""## bucles For-loop
### Los bucles for-loop iteran sobre una secuencia
#### Una secuencia puede ser una cadena, una colección (como una lista, una tupla, un diccionario, un conjunto) o un objeto especial (como un objeto de rango, un objeto de enumeración, un objeto zip)
#### La diferencia entre las colecciones (y cadenas) y los últimos objetos especiales mencionados es que las colecciones (y cadenas) son secuencias que están completamente almacenadas en la memoria de la computadora. Los objetos range, enumerate y zip son objetos especiales que liberan un valor uno por uno. El almacenamiento que toman estos objetos lo toma una función que genera la secuencia y un estado que describe lo que estaba haciendo el objeto especial en el momento en que entregó un valor.
#### Una función normal genera un valor (por ejemplo, una lista) y después de esa generación, toda la función desaparece de la memoria de la computadora. Si se vuelve a llamar es como si se llamara a la función por primera vez
#### Un objeto generador permanece en la memoria, como una computadora en hibernación. Si una computadora está en hibernación, simplemente comienza de nuevo donde se quedó, un objeto generador también sabe exactamente dónde estaba cuando se lo vuelve a llamar.
#### La ventaja es que solo tiene que almacenar la función que produce los valores y no toda la lista resultante. Esto puede ahorrar mucho espacio en la memoria.
#### Técnicamente, esto se hace mediante la declaración de rendimiento. La próxima semana discutiremos las funciones y le mostraremos cómo usar la declaración de rendimiento usted mismo.

#### Sinataxis
```python
for <name> in <string|list|tuple|set|dictionary|range object|enumerate object|zip object>:
    <statement-1>
    <statement-2>
    ...
else:                # condicional else es opcionl     
    <statement-3>    # Todos estos statements son ejecutados a menos que haya un break o ser termine el bucle
    <statement-4>    
    ...
<|> : Significa or 
<statement-1> and <statement-2> pueden ser <break> or <continue>
<break> para el bucle and el programa se ejcuta una sola vez
<continue> para las iteraciones y ejecuta la siguiente iteracion y se acaba
```

### For-loop iterando sobre una cadena o string
"""

string_1 = 'abcd'

for character in string_1:
    if character == 'e':
        print('Found it')
        break
else:
    print("Didn\'t find it")

print("Ready")

string_1  =  'abcd'
for character in string_1:
    if character  ==  'b':
        print('Found it')
        break
else:
    print('Didn\'t find it')
print('Ready')

string_1  =  'abcd'
for character in string_1:
    if character  ==  'e':
        print('Found it')
        break
else:
    print('Didn\'t find it')
print('Ready')

"""#### For-loop iterando sobre un contenedor (lista, tupla, conjunto, diccionario)
#### Tenga en cuenta que iterar sobre un diccionario puede ser un poco confuso:
* #### Si solo iteras sobre el diccionario, en realidad iteras sobre las keys
* #### Si desea iterar sobre los valores del diccionario, debe usar el método de values()
* #### Si desea iterar sobre los elementos del diccionario (las combinaciones de key y valor), debe usar el método items()
"""

list_1  =  ['a', 'b', 'c', 'd']
for character in list_1:
    if character  ==  'b':
        print('Found it')
        break
else:
    print('Didn\'t find it')
print('ready')

tuple_1  =  'a', 'b', 'c', 'd'
for character in tuple_1:
    if character  ==  'e':
        print('Found it')
        break
else:
    print('Didn\'t find it')
print('ready')

set_1  =  {'a', 'b', 'c', 'd'}
for character in set_1:
    if character  ==  'a':
        print('Found it')
        break
else:
    print('Didn\'t find it')
print('ready')

dictionary_1  =  {1:'a', 2:'b', 3:'c', 4:'d'}
for character in dictionary_1:
    if character  ==  1:
        print('Found it')
        break
else:
    print('dictionary_1idn\'t find it')
print('ready')

dictionary_1  =  {1:'a', 2:'b', 3:'c', 4:'d'}
for character in dictionary_1.keys():
    if character  ==  1:
        print('Found it')
        break
else:
    print('dictionary_1idn\'t find it')
print('ready')

dictionary_1  =  {1:'a', 2:'b', 3:'c', 4:'d'}
for character in dictionary_1.values():
    if character  ==  'e':
        print('Found it')
        break
else:
    print('dictionary_1idn\'t find it')
print('ready')

dictionary_1  =  {1:'a', 2:'b', 3:'c', 4:'d'}
for key, character in dictionary_1.items():
    if character  ==  'b':
        print(f'Found it, character {character} has key {key}')
        break
else:
    print('dictionary_1idn\'t find it')
print('ready')

"""### For loop iterando sobre un rango

#### ¿Qué es un rango?
#### Puede comparar un rango con una porción de una lista, como puede ver en los siguientes ejemplos. La diferencia es que una porción de una lista se almacenará completa como un nuevo objeto de lista en la memoria de la computadora, mientras que un objeto de rango no almacena todos los valores a la vez en la memoria, pero cada vez que se usa entregará el siguiente valor.

#### Sintaxis
```python
for <variable> in range(<start><end><step>):
    <statement-1>
    <statement-2>
    ...
else:                    
    <statement-3>    
    <statement-3>    
    ...
<start><end><step> funciona exactamente como recortar una cadena o una lista, etc, asi que si quieres revisa otra vez y acuerdate que el valor final no esta incluido. Hay los mismos datos par <empezar> y <step>. Por default el inicio es 0, para step es 1.para el final no hay default asi que un obheto range necesita al menos un valor

```
"""

range_1 = range(2, 8, 2) 
print(type(range_1), range_1)

print(list(range_1))

list_1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(list(range(2, 8, 2)) == list_1[2:8:2])

print(list(range(2, 4, 2)) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10][2:4:2])

"""#### Puede usar la iteración en un rango si sabe exactamente cuántas veces desea ejecutar el bloque de codificación

#### Ejemplo-1: puede usar un _ si no necesita el valor
#### NB esto es una convención. En Python, se supone que no debe usar nombres que comiencen con uno _, sin embargo, puede hacerlo.
"""

# Es Pythonic y se ve avanzado pero es muy simple :)
for _ in range(5): 
    print(1)

# No tan Pythonic pero funciona 
for _ in range(5): 
    print(_)

"""#### Ejemplo-2: usar un nombre que debe ser guardado"""

sum_of_integers = 0
for i in range(5):
    sum_of_integers += i**2
print(sum_of_integers)

"""### For-loop iterando sobre un objeto enumerado
#### Un objeto de enumeración crea un índice para los elementos en una secuencia
#### Algunas secuencias como conjuntos y diccionarios no tienen un índice numérico pero desea usar un índice
#### A veces desea comenzar el índice con un número diferente, p. 1
#### El objeto de enumeración necesita dos parámetros, una secuencia y un índice inicial, cuyo valor predeterminado es 0
"""

for index, digit in enumerate([1, 2, 3, 2]) :
    print(f"index is {index}, digit is {digit}")

for index, digit in enumerate((1, 2, 3, 2), 1):
    print(f"index is {index}, digit is {digit}")

for index, digit in enumerate({1, 2, 3, 2}, 2):
    print(f"index is {index}, digit is {digit}")

for index, letter in enumerate('abcde', 3):
    print(f"index is {index}, letter is {letter}")

"""### For-loop iterando sobre un objeto zip 
#### Un objeto tiene dos o mas objetos juntos
"""

for digit,  letter in zip([1, 2, 3], ['a', 'b', 'c']) :
    print(f"digit is {digit},  letter is {letter}")

"""#### Entonces puede comprimir dos listas juntas, pero en realidad puede comprimir todo tipo de secuencias juntas. Tenga en cuenta que si una de las secuencias es un diccionario, comprima las claves y no los valores"""

digits_and_letters = zip([1, 2, 3], ['a', 'b', 'c'])
print(digits_and_letters)
print(list(digits_and_letters))

digits_and_letters = zip([1, 2, 3], ('a', 'b', 'c'))
print(list(digits_and_letters))

digits_and_letters = zip(('1', '2', '3'), {'a', 'b', 'c'})
print(list(digits_and_letters))

digits_and_letters = zip([1, 2, 3], {1:'a', 2:'b', 3:'c'})
print(list(digits_and_letters))

"""#### Puedes comprimir más de 2 secuencias juntas"""

digits_and_letters = zip([1, 2, 3], ('a', 'b', 'c'), 'ghi')
print(list(digits_and_letters))

"""#### Cuando desea comprimir secuencias de diferentes longitudes, el contenedor con la longitud más corta decide el resultado"""

digits_and_letters = zip([1,2,3,4,5,6,7,8,9,10], 'abc')
print(list(digits_and_letters))

"""## While-loop

#### Sintaxis
```python
while <condition-1>:
    <statement-1>
    <statement-2>
    ...
else:                   
    <statement-3>     
    <statement-3>    
    ...

```

### El while-loop es el bucle más simple implementado en Python. En estos días, los programadores usan principalmente bucles for-loop, ya que los bucles for-loop son más potentes que los bucles while-loop. Sin embargo, algunas tareas se realizan mejor con un bucle while-loop
### En realidad, podría reemplazar todos los bucles for-loops por bucles while-loop, al revés no es posible

#### Ejemplos
"""

list_1 = ['a', 'b', 'c', 'd']


while list_1:
    #letter = list_1.pop(0)
    print('1')

list_1 = ['a', 'b', 'c', 'd']


while list_1:
    letter = list_1.pop(0)

    # El metodo pop lo que hace es que elimina un elemento de una lista y lo imprime
    # pop(0) para eliiminar el primer valor
    # pop(-1) elimina el ultimo valor
    print(letter)
    if letter == 'b':
        print('Found it')
        break
else:
    print('Didn\'t find it')
print('ready')

list_1 = ['a', 'b', 'c', 'd']
while list_1:
    letter = list_1.pop(-1)
    print(letter)
    if letter == 'e':
        print('Found it')
        break
else:
    print('Didn\'t find it')
print('ready')

list_1 = ['a', 'b', 'c', 'd']
while list_1:
    letter = list_1.pop(0)  
    print(letter)

list_1 = ['a', 'b', 'c', 'd']
while list_1:
    letter = list_1.pop(-1)  
    print(letter)

list_1 = ['a', 'b', 'c', 'd']
while list_1:
    letter = list_1.pop(-1)  
    print(letter)

"""#### Si bien la mayoría de los ejemplos anteriores también se pueden realizar fácilmente con un for-loop, el siguiente se realiza más fácilmente con un while-loop. Esta es una forma estándar en Python de probar la entrada proporcionada por el usuario."""

while True:
    name = input('What is your name?')
    if name != '' and name.isalpha():
        break
print(f"Your name is {name}")

"""#### Al igual que con un for-loop, puede usar la instrucción continuar y romper en un while-loop. Hay una cosa complicada cuando se usa continuar dentro de un while-loop. El bucle se ejecutará sin probar la condición. Puedes verlo por ti mismo en el siguiente ejemplo. Antes de hacer eso, guarde su cuaderno haciendo clic en el primer icono en la tercera fila del cuaderno. Como la condición nunca se probará, creó un bucle infinito. Verá aparecer un asterisco a la izquierda del programa. Para salir del bucle, seleccione Kernel en el menú, seleccione Reiniciar, confirme el reinicio y debería estar listo para comenzar.
#### No es una mala idea probar esto. Cada programador entrará en un bucle infinito de vez en cuando, así que es mejor que sepas qué hacer
"""

a = 1
while a < 12:
    continue
    a += 1

"""## Atajos

### Conditional expressions

#### Sinatxis de condicionales
```python
<expression-1> if <condition> else <expression-2>

```

#### Este condicional
"""

integer_1 = 3
if integer_1 > 2:
    result = "High"
else:
    result = "list_1ow"
print(result)

"""#### puede ser reemplazado por"""

integer_1 = 3
result  =  "High" if integer_1 > 2 else "Low"
print(result)

"""#### o por esto"""

integer_1 = 0
print("High" if integer_1 > 2 else "Low")

"""### Listas y otras comprensiones

#### Sintaxis de comprensiones
```python
[<expression> for <variable> in <list> if <condition>] # comprensino de lista
{<expression-1>:<expression-2> for <variable> in <list> if <condition>} # comprension para diccionario
{<expression> for <variable> in <list> if <condition>} # comprension para set 
(<expression> for <variable> in <list> if <condition>) 
# la clausula if no es necesaria 
```

#### This for-loop
"""

list_1 = [1, 2, 3, 4]
result = []
for n in list_1:
    # el operador % da el residuo de una division
    # esto es llamado el modulo 2 
    # enronces probamos si es que n es impar
    # n % 2 == 1 es verdadero si n es impar 
    if n % 2 == 0:
        # agregamos el resultado a una lista
        result.append(n**2)
print(result)

"""#### puede ser reemplazado por una comprension de lista"""

list_1 = [1, 2, 3, 4]
result  =  [n ** 2 for n in list_1 if n % 2 == 0] # crea una lista
print(result)

"""#### Tambien podemos crear un diccionario de esta manera"""

list_1 = [1, 2, 3, 4]
result  =  {n:n ** 2 for n in list_1 if n % 2 == 0}
print(result)
# El metodo items de un diccionario da una lista de tuplas cada una con su key y su valor
print(list(result.items()))
# lista de keys
print(list(result.keys()))
# Lista de resultados
print(list(result.values()))

list_1 = [1, 2, 3, 4]
result  =  {n ** 2 for n in list_1 if n % 2 == 0}
print(result)

list_1 = [1, 2, 3, 4]
result  =  (n ** 2 for n in list_1 if n % 2 == 0)
print(result)
# mas parecido a crear un rango

for x in result:
    print(x)

"""### No hay una comprension para una tupla pero esto funciona"""

list_1 = [1, 2, 3, 4]
# We construct a generator object 
result  =  (n ** 2 for n in list_1 if n % 2 == 0)
# which we convert into a tuple
result = tuple(result)
print(result)

"""### Si quieres saber por qué no hay comprensiones de tuplas? Googlea 'comprensiones de tupla de Python'. Encontrarás como uno de los primeros resultados [https://stackoverflow.com/questions/16940293/why-is-there-no-tuple-comprehension-in-python](https://stackoverflow.com/questions/16940293 /why-is-there-no-tuple-comprehension-in-python), lea las preguntas y respuestas si está interesado y recuerda que si tienes una pregunta un poco difícil googlea, los resultados en [https://stackoverflow ](https://stackoverflow) son realmente los primeros en aparcer.

# Preguntas

## 1 Programa la impresión de una tabla de multiplicar para todos los números entre 1 y 10, usando For-loops
## Rendimiento esperado:
     1   times  1  =    1
     1   times  2  =    2
     ...
     1   times 10  =   10
     ...
    10   times 10  =  100
"""

blackpink=1
Lisa=10
for num1 in range (blackpink, Lisa + 1):
  print(f'Tabla de multiplicar del {num1}:')
  for num2 in range(blackpink, Lisa+1):
    print(f'{num1} times {num2} = {num1*num2}')
    print()

"""## 2 Programe un calendario (para todos los meses) para 2020 usando For-loops
## Rendimiento esperado:
     January                     
     Mon Tue Wed Thu Fri Sat Sun  
              1   2   3   4   5
      6   7   8   9  10  11  12
     13  14  15  16  17  18  19
     20  21  22  23  24  25  26
     27  28  29  30  31
     
     February
     Mon Tue Wed Thu Fri Sat Sun
                           1   2
"""

import calendar
yy=2020
for m in range (1, 13):
  print(calendar.month(yy,m))

"""## 3 Programe la siguiente regulación fiscal, usando datos ficticios con declaraciones condicionales, use las tres cláusulas (if, elif, else) al menos una vez
Si el valor del paquete es inferior a 20 no tienes que pagar ningún impuesto de importación
Si el valor del paquete está entre 20 y 30 pagas 10% de impuesto de importación sobre el valor total
Si el valor del paquete está entre 30 y 60, paga un impuesto de importación adicional del 7% sobre el valor superior a 30
Si el valor del paquete es superior a 60, paga un impuesto de importación adicional del 3% sobre el valor superior a 60

Si el valor del paquete es superior a 10 pagas el 20% de IVA sobre la suma total del valor e impuesto de importación

El valor del paquete debe establecerse en una variable y debe probar si su programa funciona para diferentes valores.
### Salida esperada (ejemplo):
El valor del paquete fue de 25,00, el impuesto de importación es de 2,50, el IVA es de 5,50, el total es de 33,00.
"""

blackpink = float (input (" Ingrese el valor "))
if blackpink > 10:
  Rose = blackpink * 0.2
  if blackpink > 60:
    Jisoo= blackpink*0.03
  elif blackpink <60 and blackpink > 30:
    Jisoo = blackpink * 0.07
  elif blackpink > 20 and blackpink <30:
    Jisoo = blackpink * 0.1
  print ("El valor del paquete fue de ", blackpink, ", el impuesto de importación es de ", Jisoo, ", el IVA es de " , Rose, "el total es de ", blackpink + Jisoo + Rose )
else :
  print ("para el paquete con valor de ", blackpink, "no se cancela ningún costo adicional ")

"""## 4 Reescribe el siguiente programa reemplazando la declaración condicional con expresiones condicionales"""

a = -1
if a == 0:
    result = "= 0"
elif a>1:
    result = "> 1"
else:
    result = "<= 1"
print(result)

a = -1
result  =  "=0" if a==0 else ">1" if a>1 else "<=1"
print(result)

"""## 5 Reescriba el siguiente programa reemplazando la lista de comprensión con un while-loop"""

list_1 = [1, 2, 3, 4]
result  =  [digit ** 2 for digit in list_1 if digit % 2 == 0]
print(result)

list_1 = [1, 2, 3, 4]
a=[0,0]
i=0
while list_1:
    for x in list_1:
        if x%2==0:
            a[i]=x**2
            i=i+1
    print(a)
    break

a=1
while a<5:
    if a%2==0:
        print(a**2)
    a=a+1

"""## 6 En la clase 1 te mostramos las siguientes afirmaciones:"""

a = 1
b = 1
print(a is b)

a = 1000
b = 1000
print(a is b)

"""Y, por supuesto, tienes curiosidad por la diferencia. Aprendimos en la clase 1 que los números enteros -5 hasta 255 fueron internados (guardados en disco) cuando comenzó Python, esto significa que los objetos con estos valores ya estaban creados. Ahora deseaamos escribir un programa que nos diga que 256 es de hecho el primer número entero que Python no esta guardado en disco.

Escrbimos el siguiente programa y ahora necsitamos explicar por qué este programa imprimirá "Sorpresa". ¿No debería romperse mientras se procesa el número entero 256, ya que ese número no está guardado internamente?
"""

for x in range(1000):
    a = x
    b = x
    if not (a is b):
        print(f"the highest integer {x-1}")
        break
else:
    print("Surprise")

"""## 7 Vuelva a escribir la siguiente declaración sin un bucle y solo usando declaraciones condicionales:"""

i = 1
while i < 4:
    print(i)
    i +=1

a = 1
if a==1:
    print(a)
    a=a+1
    if a==2:
        print(a)
        a=a+1
        if a==3:
            print(a)